<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>10ç§’ã‚¸ãƒ£ãƒ–é€£æ‰“ãƒãƒ£ãƒ¬ãƒ³ã‚¸</title>
  <style>
    :root {
      --bg: radial-gradient(circle at 30% 30%, #101220, #05060e 60%);
      --panel: rgba(255, 255, 255, 0.06);
      --text: #e8f6ff;
      --accent: #4ef0c0;
      --accent-2: #ff6b9a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: 'Noto Sans JP', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .app {
      width: min(920px, 100%);
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      backdrop-filter: blur(6px);
    }
    header {
      padding: 20px 24px;
      display: flex;
      align-items: center;
      gap: 16px;
      background: linear-gradient(135deg, rgba(78, 240, 192, 0.18), rgba(255, 107, 154, 0.2));
    }
    header h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.04em;
    }
    header p {
      margin: 4px 0 0;
      color: #cdd9e5;
      font-size: 14px;
    }
    .content {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 16px;
      padding: 20px 24px 24px;
    }
    .board {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .camera {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #03060f;
      border: 1px solid rgba(255, 255, 255, 0.08);
      min-height: 260px;
      isolation: isolate;
    }
    video, canvas {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
    }
    .camera canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .score {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      text-align: center;
    }
    .score div {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }
    .score .label {
      font-size: 14px;
      color: #c9d6e3;
    }
    .score .value {
      font-size: 34px;
      margin-top: 6px;
      color: var(--accent);
      font-variant-numeric: tabular-nums;
    }
    .status {
      font-size: 15px;
      color: #c9d6e3;
    }
    .timer {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 16px;
      color: #cde6ff;
    }
    .bar {
      flex: 1;
      height: 10px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .bar-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width 0.1s ease-out;
    }
    .hands {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
    .hand-card {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }
    .hand-card h3 {
      margin: 0 0 4px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
    }
    .hand-card .count {
      font-size: 28px;
      margin: 6px 0 0;
      font-variant-numeric: tabular-nums;
    }
    .hand-card kbd {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.25);
      font-weight: 600;
      color: #e8f6ff;
      min-width: 28px;
      text-align: center;
    }
    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .controls .hint { color: #c9d6e3; font-size: 14px; }
    button {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 12px 18px;
      background: linear-gradient(135deg, #4ef0c0, #34b3ff);
      color: #04131d;
      font-weight: 700;
      font-size: 15px;
      letter-spacing: 0.03em;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(52, 179, 255, 0.25);
      transition: transform 0.08s ease, box-shadow 0.1s ease, filter 0.1s ease;
    }
    button.secondary {
      background: rgba(255, 255, 255, 0.08);
      color: #dfe9f5;
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    button:active {
      transform: translateY(1px);
      filter: brightness(0.95);
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .keys {
      display: grid;
      grid-template-columns: repeat(2, minmax(120px, 1fr));
      gap: 12px;
    }
    .key-card {
      border: 1px dashed rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
    }
    .key-card strong { color: var(--accent); }
    .log {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 12px;
      min-height: 80px;
      font-size: 14px;
      color: #cfd9e6;
    }
    .badge-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.05);
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ffb347;
      box-shadow: 0 0 0 4px rgba(255, 179, 71, 0.15);
    }
    .dot.ok { background: #4ef0c0; box-shadow: 0 0 0 4px rgba(78, 240, 192, 0.15); }
    .dot.warn { background: #ff6b9a; box-shadow: 0 0 0 4px rgba(255, 107, 154, 0.15); }
    .pulse {
      animation: pulse 0.18s ease;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    @media (max-width: 760px) {
      .content { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="app">
    <header>
      <div>
        <h1>10ç§’ã‚¸ãƒ£ãƒ–é€£æ‰“ãƒãƒ£ãƒ¬ãƒ³ã‚¸</h1>
        <p>ã‚¦ã‚§ãƒ–ã‚«ãƒ¡ãƒ©ã§è…•ã®å‹•ãã‚’æ¤œçŸ¥ï¼ãƒªã‚ºãƒ ã‚ˆãã‚¸ãƒ£ãƒ–ã‚’æ‰“ã¨ã†ï¼</p>
      </div>
    </header>
    <div class="content">
      <section class="board" aria-live="polite">
        <div class="score">
          <div>
            <div class="label">åˆè¨ˆã‚¸ãƒ£ãƒ–</div>
            <div id="total" class="value">0</div>
          </div>
          <div>
            <div class="label">æ®‹ã‚Šæ™‚é–“</div>
            <div id="time" class="value">10.00s</div>
          </div>
          <div>
            <div class="label">ãƒ™ã‚¹ãƒˆ</div>
            <div id="best" class="value">0</div>
          </div>
        </div>
        <div class="timer">
          <span>é€²è¡ŒçŠ¶æ³</span>
          <div class="bar" aria-hidden="true">
            <div class="bar-fill" id="bar"></div>
          </div>
        </div>
        <div class="hands">
          <div class="hand-card" id="left-card">
            <h3>å·¦ã‚¸ãƒ£ãƒ– <kbd>A</kbd> / <kbd>â†</kbd></h3>
            <div class="count" id="left-count">0</div>
          </div>
          <div class="hand-card" id="right-card">
            <h3>å³ã‚¸ãƒ£ãƒ– <kbd>L</kbd> / <kbd>â†’</kbd></h3>
            <div class="count" id="right-count">0</div>
          </div>
        </div>
        <div class="controls">
          <button id="start-btn" aria-label="ã‚²ãƒ¼ãƒ é–‹å§‹">10ç§’ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
          <button id="reset-btn" class="secondary" aria-label="ãƒªã‚»ãƒƒãƒˆ">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        <div class="status">ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚‚é–‹å§‹ã§ãã¾ã™ã€‚</div>
        <div class="log" id="log">ã‚«ãƒ¡ãƒ©è¨±å¯ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</div>
      </section>
      <aside class="board">
        <h3>éŠã³æ–¹</h3>
        <div class="camera" id="camera-block">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>
        <div class="controls">
          <button id="camera-btn" class="secondary" aria-label="ã‚«ãƒ¡ãƒ©ã‚’æœ‰åŠ¹åŒ–">ã‚«ãƒ¡ãƒ©è¨±å¯</button>
          <div class="hint">TensorFlow MoveNetã§æ‰‹ã®ä¼¸ã³ã‚’è‡ªå‹•æ¤œçŸ¥ã—ã¾ã™ã€‚</div>
        </div>
        <div class="badge-row" aria-live="polite">
          <div class="badge"><span class="dot" id="cam-dot"></span><span id="cam-status">ã‚«ãƒ¡ãƒ©å¾…æ©Ÿä¸­</span></div>
          <div class="badge"><span class="dot" id="model-dot"></span><span id="model-status">ãƒ¢ãƒ‡ãƒ«æœªãƒ­ãƒ¼ãƒ‰</span></div>
          <div class="badge"><span class="dot" id="pose-dot"></span><span id="pose-status">ãƒãƒ¼ã‚ºæœªæ¤œå‡º</span></div>
        </div>
        <div class="keys">
          <div class="key-card">å·¦æ‰‹ï¼š<strong>A</strong> / <strong>â†</strong></div>
          <div class="key-card">å³æ‰‹ï¼š<strong>L</strong> / <strong>â†’</strong></div>
          <div class="key-card">é–‹å§‹ï¼š<strong>ã‚¹ãƒšãƒ¼ã‚¹</strong></div>
          <div class="key-card">åœæ­¢ï¼š<strong>ãƒªã‚»ãƒƒãƒˆ</strong></div>
        </div>
        <p style="margin:12px 0 0; color:#c9d6e3; font-size:14px;">ä¸¡è‚©ã‚’æ˜ ã—ã€æ‹³ã‚’å‰ã«çªãå‡ºã™ã¨ã‚«ã‚¦ãƒ³ãƒˆã•ã‚Œã¾ã™ã€‚</p>
      </aside>
    </div>
  </main>

  <script>
    // ã‚¹ã‚¯ãƒªãƒ—ãƒˆå‹•çš„èª­ã¿è¾¼ã¿
    async function loadScripts() {
      const scripts = [
        'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js',
        'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.18.0/dist/tf-backend-webgl.min.js',
        'https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@4.1.0/dist/pose-detection.min.js'
      ];
      
      for (const src of scripts) {
        await new Promise((resolve) => {
          const script = document.createElement('script');
          script.src = src;
          script.onload = resolve;
          script.onerror = () => {
            console.error('Failed to load:', src);
            resolve();
          };
          document.head.appendChild(script);
        });
      }
    }
    
    window.scriptsReady = loadScripts();
  </script>

  <script>
    const totalEl = document.getElementById('total');
    const timeEl = document.getElementById('time');
    const bestEl = document.getElementById('best');
    const barFill = document.getElementById('bar');
    const leftCountEl = document.getElementById('left-count');
    const rightCountEl = document.getElementById('right-count');
    const logEl = document.getElementById('log');
    const leftCard = document.getElementById('left-card');
    const rightCard = document.getElementById('right-card');
    const startBtn = document.getElementById('start-btn');
    const resetBtn = document.getElementById('reset-btn');
    const cameraBtn = document.getElementById('camera-btn');
    const videoEl = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const camDot = document.getElementById('cam-dot');
    const camStatus = document.getElementById('cam-status');
    const modelDot = document.getElementById('model-dot');
    const modelStatus = document.getElementById('model-status');
    const poseDot = document.getElementById('pose-dot');
    const poseStatus = document.getElementById('pose-status');

    const DURATION = 10000;
    let timerId = null;
    let startTime = null;
    let left = 0;
    let right = 0;
    let best = 0;
    let running = false;
    let detector = null;
    let cameraReady = false;
    let poseLoopId = null;
    let lastPoseTs = 0;
    let pairs = [];
    const jabState = {
      left: { extended: false, lastPunch: 0 },
      right: { extended: false, lastPunch: 0 },
    };

    function updateBadge(dot, label, message, state = 'ok') {
      dot.classList.toggle('ok', state === 'ok');
      dot.classList.toggle('warn', state === 'warn');
      label.textContent = message;
    }

    function updateCounts() {
      const total = left + right;
      totalEl.textContent = total;
      leftCountEl.textContent = left;
      rightCountEl.textContent = right;
      if (total > best) {
        best = total;
        bestEl.textContent = best;
        log(`ğŸ‰ è¨˜éŒ²æ›´æ–°ï¼ ${best} ã‚¸ãƒ£ãƒ–`);
      }
    }

    function setTime(ms) {
      const seconds = Math.max(0, ms / 1000);
      timeEl.textContent = `${seconds.toFixed(2)}s`;
      const progress = Math.min(1, (DURATION - ms) / DURATION);
      barFill.style.width = `${progress * 100}%`;
    }

    function log(message) {
      logEl.textContent = message;
    }

    function pulse(el) {
      el.classList.remove('pulse');
      void el.offsetWidth;
      el.classList.add('pulse');
    }

    function startGame() {
      if (running) return;
      running = true;
      left = 0;
      right = 0;
      updateCounts();
      startTime = performance.now();
      setTime(DURATION);
      log('è¨ˆæ¸¬ä¸­ï¼ãƒªã‚ºãƒ ã‚ˆãã‚¸ãƒ£ãƒ–ã‚’æ‰“ã¨ã†ï¼');
      timerId = requestAnimationFrame(tick);
    }

    function endGame() {
      if (!running) return;
      running = false;
      if (timerId) cancelAnimationFrame(timerId);
      timerId = null;
      setTime(0);
      log(`çµæœ: åˆè¨ˆ ${left + right} ã‚¸ãƒ£ãƒ–ã€‚ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã‚ˆã†ï¼`);
    }

    function resetGame() {
      if (timerId) cancelAnimationFrame(timerId);
      running = false;
      left = 0;
      right = 0;
      startTime = null;
      setTime(DURATION);
      updateCounts();
      log('æº–å‚™å®Œäº†ã€‚STARTãƒœã‚¿ãƒ³ã‹ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§è¨ˆæ¸¬é–‹å§‹ï¼');
    }

    function tick(now) {
      const elapsed = now - startTime;
      const remaining = Math.max(0, DURATION - elapsed);
      setTime(remaining);
      if (remaining <= 0) {
        endGame();
        return;
      }
      timerId = requestAnimationFrame(tick);
    }

    function handlePunch(key) {
      if (!running) return;
      const k = key.toLowerCase();
      if (k === 'a' || key === 'ArrowLeft') {
        left += 1;
        updateCounts();
        pulse(leftCard);
      } else if (k === 'l' || key === 'ArrowRight') {
        right += 1;
        updateCounts();
        pulse(rightCard);
      }
    }

    function drawPose(pose) {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      if (!pose?.keypoints) return;
      const keypoints = pose.keypoints.filter((kp) => kp.score >= 0.3);
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
      pairs.forEach(([a, b]) => {
        const kp1 = pose.keypoints[a];
        const kp2 = pose.keypoints[b];
        if (!kp1 || !kp2 || kp1.score < 0.3 || kp2.score < 0.3) return;
        ctx.beginPath();
        ctx.moveTo(kp1.x, kp1.y);
        ctx.lineTo(kp2.x, kp2.y);
        ctx.stroke();
      });
      keypoints.forEach((kp) => {
        ctx.beginPath();
        ctx.arc(kp.x, kp.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = kp.name?.includes('right') ? '#ff6b9a' : '#4ef0c0';
        ctx.fill();
      });
    }

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function detectJab(side, wrist, shoulder, hip, timestamp) {
      if (!wrist || !shoulder || !hip) return;
      if (wrist.score < 0.3 || shoulder.score < 0.3 || hip.score < 0.3) return;
      const ref = distance(shoulder, hip) || 1;
      const arm = distance(wrist, shoulder) / ref;
      const extended = arm > 1.15;
      const state = jabState[side];
      const cooldown = 220;
      if (extended && !state.extended && timestamp - state.lastPunch > cooldown) {
        if (side === 'left') {
          left += 1;
          pulse(leftCard);
        } else {
          right += 1;
          pulse(rightCard);
        }
        state.lastPunch = timestamp;
        updateCounts();
      }
      state.extended = extended;
    }

    async function poseLoop() {
      if (!detector || videoEl.readyState < 2) {
        poseLoopId = requestAnimationFrame(poseLoop);
        return;
      }
      try {
        const poses = await detector.estimatePoses(videoEl, { flipHorizontal: true });
        const ts = performance.now();
        overlay.width = videoEl.videoWidth;
        overlay.height = videoEl.videoHeight;
        const pose = poses[0];
        drawPose(pose);
        if (pose?.keypoints?.length) {
          const kp = Object.fromEntries(pose.keypoints.map((p) => [p.name, p]));
          updateBadge(poseDot, poseStatus, 'ãƒãƒ¼ã‚ºæ¤œå‡ºä¸­', 'ok');
          lastPoseTs = ts;
          if (running) {
            detectJab('left', kp['left_wrist'], kp['left_shoulder'], kp['left_hip'], ts);
            detectJab('right', kp['right_wrist'], kp['right_shoulder'], kp['right_hip'], ts);
          }
        } else if (ts - lastPoseTs > 1500) {
          updateBadge(poseDot, poseStatus, 'ãƒãƒ¼ã‚ºæœªæ¤œå‡º', 'warn');
        }
      } catch (e) {
        console.error('Pose detection error:', e);
      }
      poseLoopId = requestAnimationFrame(poseLoop);
    }

    async function initDetector() {
      if (detector) return;
      try {
        // ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
        await window.scriptsReady;
        
        if (typeof poseDetection === 'undefined') {
          throw new Error('poseDetection ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
        }
        
        await tf.ready();
        await tf.setBackend('webgl');
        updateBadge(modelDot, modelStatus, 'ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...', 'warn');
        
        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          { modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER }
        );
        pairs = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
        updateBadge(modelDot, modelStatus, 'MoveNet ãƒ­ãƒ¼ãƒ‰å®Œäº†', 'ok');
        log('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ï¼è‚©ã‹ã‚‰æ‹³ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«èª¿æ•´ã—ã¦ãã ã•ã„ã€‚');
        poseLoop();
      } catch (e) {
        console.error('Model loading error:', e);
        log('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + e.message);
      }
    }

    async function initCamera() {
      if (cameraReady) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user' },
          audio: false
        });
        videoEl.srcObject = stream;
        await videoEl.play();
        cameraReady = true;
        updateBadge(camDot, camStatus, 'ã‚«ãƒ¡ãƒ©ç¨¼åƒä¸­', 'ok');
        log('ã‚«ãƒ¡ãƒ©æº–å‚™OKï¼ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...');
        await initDetector();
      } catch (e) {
        console.error('Camera error:', e);
        updateBadge(camDot, camStatus, 'ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼', 'warn');
        log('ã‚«ãƒ¡ãƒ©ã®è¨±å¯ãŒå¿…è¦ã§ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'Space') {
        e.preventDefault();
        if (!running) startGame();
        return;
      }
      handlePunch(e.key);
    });

    startBtn.addEventListener('click', startGame);
    resetBtn.addEventListener('click', resetGame);
    cameraBtn.addEventListener('click', () => {
      cameraBtn.disabled = true;
      cameraBtn.textContent = 'æº–å‚™ä¸­...';
      initCamera().finally(() => {
        cameraBtn.textContent = cameraReady ? 'ã‚«ãƒ¡ãƒ©ç¨¼åƒä¸­' : 'ã‚«ãƒ¡ãƒ©è¨±å¯';
        cameraBtn.disabled = cameraReady;
      });
    });

    setTime(DURATION);
    updateBadge(camDot, camStatus, 'ã‚«ãƒ¡ãƒ©å¾…æ©Ÿä¸­', 'warn');
    updateBadge(modelDot, modelStatus, 'ãƒ¢ãƒ‡ãƒ«æœªãƒ­ãƒ¼ãƒ‰', 'warn');
    updateBadge(poseDot, poseStatus, 'ãƒãƒ¼ã‚ºæœªæ¤œå‡º', 'warn');
  </script>
</body>
</html>
