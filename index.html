<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>10秒ジャブ連打チャレンジ</title>
  <style>
    :root {
      --bg: radial-gradient(circle at 30% 30%, #101220, #05060e 60%);
      --panel: rgba(255, 255, 255, 0.06);
      --text: #e8f6ff;
      --accent: #4ef0c0;
      --accent-2: #ff6b9a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: 'Noto Sans JP', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .app {
      width: min(920px, 100%);
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      backdrop-filter: blur(6px);
    }
    header {
      padding: 20px 24px;
      display: flex;
      align-items: center;
      gap: 16px;
      background: linear-gradient(135deg, rgba(78, 240, 192, 0.18), rgba(255, 107, 154, 0.2));
    }
    header h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.04em;
    }
    header p {
      margin: 4px 0 0;
      color: #cdd9e5;
      font-size: 14px;
    }
    .content {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 16px;
      padding: 20px 24px 24px;
    }
    .board {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .camera {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #03060f;
      border: 1px solid rgba(255, 255, 255, 0.08);
      min-height: 260px;
      isolation: isolate;
    }
    video, canvas {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
    }
    .camera canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .score {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      text-align: center;
    }
    .score div {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }
    .score .value {
      font-size: 34px;
      margin-top: 6px;
      color: var(--accent);
      font-variant-numeric: tabular-nums;
    }
    .status {
      font-size: 15px;
      color: #c9d6e3;
    }
    .timer {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 16px;
      color: #cde6ff;
    }
    .bar {
      flex: 1;
      height: 10px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .bar-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width 0.1s ease-out;
    }
    .hands {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
    .hand-card {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }
    .hand-card h3 {
      margin: 0 0 4px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
    }
    .hand-card .count {
      font-size: 28px;
      margin: 6px 0 0;
      font-variant-numeric: tabular-nums;
    }
    .hand-card kbd {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.25);
      font-weight: 600;
      color: #e8f6ff;
      min-width: 28px;
      text-align: center;
    }
    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .controls .hint { color: #c9d6e3; font-size: 14px; }
    button {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 12px 18px;
      background: linear-gradient(135deg, #4ef0c0, #34b3ff);
      color: #04131d;
      font-weight: 700;
      font-size: 15px;
      letter-spacing: 0.03em;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(52, 179, 255, 0.25);
      transition: transform 0.08s ease, box-shadow 0.1s ease, filter 0.1s ease;
    }
    button.secondary {
      background: rgba(255, 255, 255, 0.08);
      color: #dfe9f5;
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    button:active {
      transform: translateY(1px);
      filter: brightness(0.95);
    }
    .keys {
      display: grid;
      grid-template-columns: repeat(2, minmax(120px, 1fr));
      gap: 12px;
    }
    .key-card {
      border: 1px dashed rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .key-card strong { color: var(--accent); }
    .log {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 12px;
      min-height: 80px;
      font-size: 14px;
      color: #cfd9e6;
    }
    .badge-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.05);
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ffb347;
      box-shadow: 0 0 0 4px rgba(255, 179, 71, 0.15);
    }
    .dot.ok { background: #4ef0c0; box-shadow: 0 0 0 4px rgba(78, 240, 192, 0.15); }
    .dot.warn { background: #ff6b9a; box-shadow: 0 0 0 4px rgba(255, 107, 154, 0.15); }
    .pulse {
      animation: pulse 0.18s ease;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    @media (max-width: 760px) {
      .content { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="app">
    <header>
      <div>
        <h1>10秒ジャブ連打チャレンジ</h1>
        <p>左手と右手のキーを交互に叩いて、10秒間で何発ジャブを打てるか計測しよう！</p>
      </div>
    </header>
    <div class="content">
      <section class="board" aria-live="polite">
        <div class="score">
          <div>
            <div class="label">合計ジャブ</div>
            <div id="total" class="value">0</div>
          </div>
          <div>
            <div class="label">残り時間</div>
            <div id="time" class="value">10.00s</div>
          </div>
          <div>
            <div class="label">ベスト</div>
            <div id="best" class="value">0</div>
          </div>
        </div>
        <div class="timer">
          <span>進行状況</span>
          <div class="bar" aria-hidden="true">
            <div class="bar-fill" id="bar"></div>
          </div>
        </div>
        <div class="hands">
          <div class="hand-card" id="left-card">
            <h3>左ジャブ <kbd>A</kbd> / <kbd>←</kbd></h3>
            <div class="count" id="left-count">0</div>
          </div>
          <div class="hand-card" id="right-card">
            <h3>右ジャブ <kbd>L</kbd> / <kbd>→</kbd></h3>
            <div class="count" id="right-count">0</div>
          </div>
        </div>
        <div class="controls">
          <button id="start-btn" aria-label="ゲーム開始">10秒スタート</button>
          <button id="reset-btn" class="secondary" aria-label="リセット">リセット</button>
        </div>
        <div class="status">スペースキーでも開始できます。キーを押した瞬間にカウントされます（長押しは1回扱い）。</div>
        <div class="log" id="log">準備完了。STARTボタンかスペースキーで計測開始！</div>
      </section>
      <aside class="board">
        <h3>遊び方</h3>
        <div class="camera" id="camera-block">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>
        <div class="controls">
          <button id="camera-btn" class="secondary" aria-label="カメラを有効化">カメラ許可</button>
          <div class="hint">TensorFlow MoveNetで手の伸びを検知し、左右のジャブを自動カウントします。</div>
        </div>
        <div class="badge-row" aria-live="polite">
          <div class="badge"><span class="dot" id="cam-dot"></span><span id="cam-status">カメラ待機中</span></div>
          <div class="badge"><span class="dot" id="model-dot"></span><span id="model-status">モデル未ロード</span></div>
          <div class="badge"><span class="dot" id="pose-dot"></span><span id="pose-status">ポーズ未検出</span></div>
        </div>
        <div class="keys">
          <div class="key-card">左手：<strong>A</strong> / <strong>←</strong> または左手ジャブ検知</div>
          <div class="key-card">右手：<strong>L</strong> / <strong>→</strong> または右手ジャブ検知</div>
          <div class="key-card">開始：<strong>スペース</strong> または <strong>ボタン</strong></div>
          <div class="key-card">停止：<strong>リセット</strong> ボタン</div>
        </div>
        <p style="margin:12px 0 0; color:#c9d6e3; font-size:14px;">両肩を映し、拳を前に突き出すとカウントされます。身体を痛めないようウォームアップしてから挑戦してください！</p>
      </aside>
    </div>
  </main>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.18.0/dist/tf-backend-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@4.1.0/dist/pose-detection.min.js"></script>
  <script>
    const totalEl = document.getElementById('total');
    const timeEl = document.getElementById('time');
    const bestEl = document.getElementById('best');
    const barFill = document.getElementById('bar');
    const leftCountEl = document.getElementById('left-count');
    const rightCountEl = document.getElementById('right-count');
    const logEl = document.getElementById('log');
    const leftCard = document.getElementById('left-card');
    const rightCard = document.getElementById('right-card');
    const startBtn = document.getElementById('start-btn');
    const resetBtn = document.getElementById('reset-btn');
    const cameraBtn = document.getElementById('camera-btn');
    const videoEl = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const camDot = document.getElementById('cam-dot');
    const camStatus = document.getElementById('cam-status');
    const modelDot = document.getElementById('model-dot');
    const modelStatus = document.getElementById('model-status');
    const poseDot = document.getElementById('pose-dot');
    const poseStatus = document.getElementById('pose-status');

    const DURATION = 10_000; // 10 seconds
    let timerId = null;
    let startTime = null;
    let left = 0;
    let right = 0;
    let best = Number(localStorage.getItem('jab-best') || 0);
    let running = false;
    let detector = null;
    let cameraReady = false;
    let poseLoopId = null;
    let lastPoseTs = 0;
    let pairs = [];
    const jabState = {
      left: { extended: false, lastPunch: 0 },
      right: { extended: false, lastPunch: 0 },
    };

    bestEl.textContent = best;
    updateBadge(camDot, camStatus, 'カメラ待機中', 'warn');
    updateBadge(modelDot, modelStatus, 'モデル未ロード', 'warn');
    updateBadge(poseDot, poseStatus, 'ポーズ未検出', 'warn');

    const handKeys = {
      left: ['a', 'ArrowLeft'],
      right: ['l', 'ArrowRight'],
    };

    function updateBadge(dot, label, message, state = 'ok') {
      dot.classList.toggle('ok', state === 'ok');
      dot.classList.toggle('warn', state === 'warn');
      label.textContent = message;
    }

    function updateCounts() {
      const total = left + right;
      totalEl.textContent = total;
      leftCountEl.textContent = left;
      rightCountEl.textContent = right;
      if (total > best) {
        best = total;
        bestEl.textContent = best;
        localStorage.setItem('jab-best', best);
        log(`記録更新！ ${best} ジャブ`);
      }
    }

    function setTime(ms) {
      const seconds = Math.max(0, ms / 1000);
      timeEl.textContent = `${seconds.toFixed(2)}s`;
      const progress = Math.min(1, (DURATION - ms) / DURATION);
      barFill.style.width = `${progress * 100}%`;
    }

    function log(message) {
      logEl.textContent = message;
    }

    function pulse(el) {
      el.classList.remove('pulse');
      void el.offsetWidth;
      el.classList.add('pulse');
    }

    function startGame() {
      if (running) return;
      if (!detector || !cameraReady) {
        log('カメラとモデルを準備中です…');
      }
      running = true;
      left = 0;
      right = 0;
      updateCounts();
      startTime = performance.now();
      setTime(DURATION);
      log('計測中！リズムよくジャブを打とう！');
      timerId = requestAnimationFrame(tick);
    }

    function endGame() {
      if (!running) return;
      running = false;
      if (timerId) cancelAnimationFrame(timerId);
      timerId = null;
      setTime(0);
      log(`結果: 合計 ${left + right} ジャブ。もう一度挑戦しよう！`);
    }

    function resetGame() {
      if (timerId) cancelAnimationFrame(timerId);
      running = false;
      left = 0;
      right = 0;
      startTime = null;
      setTime(DURATION);
      updateCounts();
      log('準備完了。STARTボタンかスペースキーで計測開始！');
    }

    function tick(now) {
      const elapsed = now - startTime;
      const remaining = Math.max(0, DURATION - elapsed);
      setTime(remaining);
      if (remaining <= 0) {
        endGame();
        return;
      }
      timerId = requestAnimationFrame(tick);
    }

    function handlePunch(key) {
      if (!running) return;
      if (handKeys.left.includes(key)) {
        left += 1;
        updateCounts();
        pulse(leftCard);
      } else if (handKeys.right.includes(key)) {
        right += 1;
        updateCounts();
        pulse(rightCard);
      }
    }

    function drawPose(pose) {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      if (!pose?.keypoints) return;
      const keypoints = pose.keypoints.filter((kp) => kp.score >= 0.3);
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
      pairs.forEach(([a, b]) => {
        const kp1 = pose.keypoints[a];
        const kp2 = pose.keypoints[b];
        if (!kp1 || !kp2 || kp1.score < 0.3 || kp2.score < 0.3) return;
        ctx.beginPath();
        ctx.moveTo(kp1.x, kp1.y);
        ctx.lineTo(kp2.x, kp2.y);
        ctx.stroke();
      });
      keypoints.forEach((kp) => {
        ctx.beginPath();
        ctx.arc(kp.x, kp.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = kp.name?.includes('right') ? '#ff6b9a' : '#4ef0c0';
        ctx.fill();
      });
    }

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function detectJab(side, wrist, shoulder, hip, timestamp) {
      if (!wrist || !shoulder || !hip) return;
      if (wrist.score < 0.3 || shoulder.score < 0.3 || hip.score < 0.3) return;
      const ref = distance(shoulder, hip) || 1;
      const arm = distance(wrist, shoulder) / ref;
      const extended = arm > 1.15;
      const state = jabState[side];
      const cooldown = 220;
      if (extended && !state.extended && timestamp - state.lastPunch > cooldown) {
        if (side === 'left') {
          left += 1;
          pulse(leftCard);
        } else {
          right += 1;
          pulse(rightCard);
        }
        state.lastPunch = timestamp;
        updateCounts();
      }
      state.extended = extended;
    }

    async function poseLoop() {
      if (!detector || videoEl.readyState < 2) {
        poseLoopId = requestAnimationFrame(poseLoop);
        return;
      }
      const poses = await detector.estimatePoses(videoEl, { flipHorizontal: true });
      const ts = performance.now();
      overlay.width = videoEl.videoWidth;
      overlay.height = videoEl.videoHeight;
      const pose = poses[0];
      drawPose(pose);
      if (pose?.keypoints?.length) {
        const kp = Object.fromEntries(pose.keypoints.map((p) => [p.name, p]));
        updateBadge(poseDot, poseStatus, 'ポーズ検出中', 'ok');
        lastPoseTs = ts;
        if (running) {
          detectJab('left', kp['left_wrist'], kp['left_shoulder'], kp['left_hip'], ts);
          detectJab('right', kp['right_wrist'], kp['right_shoulder'], kp['right_hip'], ts);
        }
      } else if (ts - lastPoseTs > 1500) {
        updateBadge(poseDot, poseStatus, 'ポーズ未検出', 'warn');
      }
      poseLoopId = requestAnimationFrame(poseLoop);
    }

    async function initDetector() {
      if (detector) return detector;
      await tf.ready();
      await tf.setBackend('webgl');
      modelStatus.textContent = 'モデル読み込み中…';
      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER }
      );
      pairs = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
      updateBadge(modelDot, modelStatus, 'MoveNet ロード完了', 'ok');
      log('モデル読み込み完了。肩から拳が見えるようにカメラを調整してください。');
      return detector;
    }

    async function initCamera() {
      if (cameraReady) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
        videoEl.srcObject = stream;
        await videoEl.play();
        cameraReady = true;
        updateBadge(camDot, camStatus, 'カメラ稼働中', 'ok');
        log('カメラ準備OK！肩と拳が映る位置でスタンバイ。');
        await initDetector();
        poseLoop();
      } catch (e) {
        console.error(e);
        updateBadge(camDot, camStatus, 'カメラ拒否または未接続', 'warn');
        log('カメラの許可が必要です。ブラウザ設定を確認してください。');
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'Space') {
        e.preventDefault();
        if (!running) startGame();
        return;
      }
      handlePunch(e.key);
    });

    startBtn.addEventListener('click', startGame);
    resetBtn.addEventListener('click', resetGame);
    cameraBtn.addEventListener('click', () => {
      cameraBtn.disabled = true;
      cameraBtn.textContent = '準備中...';
      initCamera().finally(() => {
        cameraBtn.textContent = cameraReady ? 'カメラ稼働中' : 'カメラ許可';
        cameraBtn.disabled = cameraReady;
      });
    });

    setTime(DURATION);
  </script>
</body>
</html>
