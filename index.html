<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>10ç§’ã‚¸ãƒ£ãƒ–é€£æ‰“ãƒãƒ£ãƒ¬ãƒ³ã‚¸</title>
  <style>
    :root {
      --bg: radial-gradient(circle at 30% 30%, #101220, #05060e 60%);
      --panel: rgba(255, 255, 255, 0.06);
      --text: #e8f6ff;
      --accent: #4ef0c0;
      --accent-2: #ff6b9a;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: 'Noto Sans JP', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: min(920px, 100%);
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.35);
      overflow: hidden;
      backdrop-filter: blur(6px);
    }

    header {
      padding: 20px 24px;
      display: flex;
      align-items: center;
      gap: 16px;
      background: linear-gradient(135deg, rgba(78, 240, 192, 0.18), rgba(255, 107, 154, 0.2));
    }

    header h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.04em;
    }

    header p {
      margin: 4px 0 0;
      color: #cdd9e5;
      font-size: 14px;
    }

    .content {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 16px;
      padding: 20px 24px 24px;
    }

    .board {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .camera {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: #03060f;
      border: 1px solid rgba(255, 255, 255, 0.08);
      min-height: 260px;
      isolation: isolate;
    }

    video,
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: cover;
    }

    .camera canvas {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .score {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      text-align: center;
    }

    .score div {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    .score .label {
      font-size: 14px;
      color: #c9d6e3;
    }

    .score .value {
      font-size: 34px;
      margin-top: 6px;
      color: var(--accent);
      font-variant-numeric: tabular-nums;
    }

    .status {
      font-size: 15px;
      color: #c9d6e3;
    }

    .timer {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 16px;
      color: #cde6ff;
    }

    .bar {
      flex: 1;
      height: 10px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .bar-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width 0.1s ease-out;
    }

    .hands {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    .hand-card {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .hand-card h3 {
      margin: 0 0 4px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
    }

    .hand-card .count {
      font-size: 28px;
      margin: 6px 0 0;
      font-variant-numeric: tabular-nums;
    }

    .hand-card kbd {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.25);
      font-weight: 600;
      color: #e8f6ff;
      min-width: 28px;
      text-align: center;
    }

    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .controls .hint {
      color: #c9d6e3;
      font-size: 14px;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 12px 18px;
      background: linear-gradient(135deg, #4ef0c0, #34b3ff);
      color: #04131d;
      font-weight: 700;
      font-size: 15px;
      letter-spacing: 0.03em;
      cursor: pointer;
      box-shadow: 0 8px 16px rgba(52, 179, 255, 0.25);
      transition: transform 0.08s ease, box-shadow 0.1s ease, filter 0.1s ease;
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.08);
      color: #dfe9f5;
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    button:active {
      transform: translateY(1px);
      filter: brightness(0.95);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .keys {
      display: grid;
      grid-template-columns: repeat(2, minmax(120px, 1fr));
      gap: 12px;
    }

    .key-card {
      border: 1px dashed rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
    }

    .key-card strong {
      color: var(--accent);
    }

    .log {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 12px;
      min-height: 80px;
      font-size: 14px;
      color: #cfd9e6;
    }

    /* ãƒ„ã‚¤ãƒ¼ãƒˆãƒœã‚¿ãƒ³ */
    .tweet-btn {
      background: linear-gradient(135deg, #1da1f2, #0d8ecf);
      color: #fff;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 12px 20px;
      border-radius: 999px;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(29, 161, 242, 0.35);
      transition: transform 0.1s ease, box-shadow 0.15s ease;
    }

    .tweet-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 24px rgba(29, 161, 242, 0.45);
    }

    .tweet-btn.show {
      display: inline-flex;
    }

    .tweet-btn svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .badge-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.05);
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ffb347;
      box-shadow: 0 0 0 4px rgba(255, 179, 71, 0.15);
    }

    .dot.ok {
      background: #4ef0c0;
      box-shadow: 0 0 0 4px rgba(78, 240, 192, 0.15);
    }

    .dot.warn {
      background: #ff6b9a;
      box-shadow: 0 0 0 4px rgba(255, 107, 154, 0.15);
    }

    .pulse {
      animation: pulse 0.18s ease;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }

    @media (max-width: 760px) {
      .content {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <main class="app">
    <header>
      <div>
        <h1>10ç§’ã‚¸ãƒ£ãƒ–é€£æ‰“ãƒãƒ£ãƒ¬ãƒ³ã‚¸</h1>
        <p>å…¨3ãƒ©ã‚¦ãƒ³ãƒ‰ã®ãƒœã‚¹ãƒãƒˆãƒ«ï¼ãƒ‘ãƒ³ãƒé€£æ‰“ã§æ•µã‚’å€’ã›ï¼</p>
      </div>
    </header>
    <div class="content">
      <section class="board" aria-live="polite">
        <div class="score">
          <div>
            <div class="label">åˆè¨ˆãƒ€ãƒ¡ãƒ¼ã‚¸</div>
            <div id="total" class="value">0</div>
          </div>
          <div>
            <div class="label">æ®‹ã‚Šæ™‚é–“</div>
            <div id="time" class="value">10.00s</div>
          </div>
          <div>
            <div class="label">ãƒ©ã‚¦ãƒ³ãƒ‰</div>
            <div id="round-display" class="value">1 / 3</div>
          </div>
        </div>
        <div class="timer">
          <span>é€²è¡ŒçŠ¶æ³</span>
          <div class="bar" aria-hidden="true">
            <div class="bar-fill" id="bar"></div>
          </div>
        </div>
        <div class="hands">
          <div class="hand-card" id="left-card">
            <h3>å·¦ã‚¸ãƒ£ãƒ– <kbd>A</kbd> / <kbd>â†</kbd></h3>
            <div class="count" id="left-count">0</div>
          </div>
          <div class="hand-card" id="right-card">
            <h3>å³ã‚¸ãƒ£ãƒ– <kbd>L</kbd> / <kbd>â†’</kbd></h3>
            <div class="count" id="right-count">0</div>
          </div>
        </div>
        <div class="controls">
          <button id="start-btn" aria-label="ã‚²ãƒ¼ãƒ é–‹å§‹">10ç§’ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
          <button id="reset-btn" class="secondary" aria-label="ãƒªã‚»ãƒƒãƒˆ">ãƒªã‚»ãƒƒãƒˆ</button>
          <button id="tweet-btn" class="tweet-btn" aria-label="çµæœã‚’ãƒ„ã‚¤ãƒ¼ãƒˆ">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
            </svg>
            çµæœã‚’ãƒ„ã‚¤ãƒ¼ãƒˆ
          </button>
        </div>
        <div class="status">ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚‚é–‹å§‹ã§ãã¾ã™ã€‚</div>
        <div class="log" id="log">ã‚«ãƒ¡ãƒ©è¨±å¯ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</div>
      </section>
      <aside class="board">
        <h3>éŠã³æ–¹</h3>
        <div class="camera" id="camera-block">
          <video id="video" playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>
        <div class="controls">
          <button id="camera-btn" class="secondary" aria-label="ã‚«ãƒ¡ãƒ©ã‚’æœ‰åŠ¹åŒ–">ã‚«ãƒ¡ãƒ©è¨±å¯</button>
          <div class="hint">TensorFlow MoveNetã§æ‰‹ã®ä¼¸ã³ã‚’è‡ªå‹•æ¤œçŸ¥ã—ã¾ã™ã€‚</div>
        </div>
        <div class="badge-row" aria-live="polite">
          <div class="badge"><span class="dot" id="cam-dot"></span><span id="cam-status">ã‚«ãƒ¡ãƒ©å¾…æ©Ÿä¸­</span></div>
          <div class="badge"><span class="dot" id="model-dot"></span><span id="model-status">ãƒ¢ãƒ‡ãƒ«æœªãƒ­ãƒ¼ãƒ‰</span></div>
          <div class="badge"><span class="dot" id="pose-dot"></span><span id="pose-status">ãƒãƒ¼ã‚ºæœªæ¤œå‡º</span></div>
        </div>
        <div class="keys">
          <div class="key-card">å·¦æ‰‹ï¼š<strong>A</strong> / <strong>â†</strong></div>
          <div class="key-card">å³æ‰‹ï¼š<strong>L</strong> / <strong>â†’</strong></div>
          <div class="key-card">é–‹å§‹ï¼š<strong>ã‚¹ãƒšãƒ¼ã‚¹</strong></div>
          <div class="key-card">åœæ­¢ï¼š<strong>ãƒªã‚»ãƒƒãƒˆ</strong></div>
        </div>
        <p style="margin:12px 0 0; color:#c9d6e3; font-size:14px;">ä¸¡è‚©ã‚’æ˜ ã—ã€æ‹³ã‚’å‰ã«çªãå‡ºã™ã¨ã‚«ã‚¦ãƒ³ãƒˆã•ã‚Œã¾ã™ã€‚</p>
      </aside>
    </div>
  </main>



  <script type="module">
    // MediaPipeãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    import { PoseLandmarker, FilesetResolver, DrawingUtils } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs';

    // DOMè¦ç´ ã®å–å¾—
    const totalEl = document.getElementById('total');
    const timeEl = document.getElementById('time');
    const bestEl = document.getElementById('best');
    const barFill = document.getElementById('bar');
    const leftCountEl = document.getElementById('left-count');
    const rightCountEl = document.getElementById('right-count');
    const logEl = document.getElementById('log');
    const leftCard = document.getElementById('left-card');
    const rightCard = document.getElementById('right-card');
    const startBtn = document.getElementById('start-btn');
    const resetBtn = document.getElementById('reset-btn');
    const cameraBtn = document.getElementById('camera-btn');
    const videoEl = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const camDot = document.getElementById('cam-dot');
    const camStatus = document.getElementById('cam-status');
    const modelDot = document.getElementById('model-dot');
    const modelStatus = document.getElementById('model-status');
    const poseDot = document.getElementById('pose-dot');
    const poseStatus = document.getElementById('pose-status');
    const tweetBtn = document.getElementById('tweet-btn');

    // ãƒ„ã‚¤ãƒ¼ãƒˆå…±æœ‰ç”¨è¨­å®š
    const GAME_URL = 'https://kg-ninja.github.io/hyakuretuken/';
    const HASHTAG = 'KGNINJA';
    // ã‚²ãƒ¼ãƒ è¨­å®š
    const START_DURATION = 10000; // åˆæœŸåˆ¶é™æ™‚é–“
    let duration = START_DURATION;
    let timerId = null;
    let startTime = null;
    let left = 0;
    let right = 0;
    let best = 0;
    let running = false;

    // ãƒ©ã‚¦ãƒ³ãƒ‰è¨­å®š
    let currentRound = 1;
    let maxRounds = 3;
    let roundClear = false;

    let poseLandmarker = null;
    let cameraReady = false;
    let poseLoopId = null;
    let lastPoseTs = 0;
    let drawingUtils = null;

    // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åˆæœŸåŒ–ï¼ˆåŠ¹æœéŸ³ç”¨ï¼‰
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    // ãƒ¬ãƒˆãƒ­ãªãƒ‘ãƒ³ãƒéŸ³ã‚’ç”Ÿæˆã—ã¦å†ç”Ÿ
    function playPunchSound() {
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      const t = audioCtx.currentTime;

      // 1. ãƒã‚¤ã‚ºç”Ÿæˆï¼ˆæ‰“æ’ƒã®è¡æ’ƒéŸ³ï¼‰
      const bufferSize = audioCtx.sampleRate * 0.15; // 0.15ç§’
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;

      // ãƒ•ã‚£ãƒ«ã‚¿ã§ã€Œã“ã‚‚ã£ãŸã€æ„Ÿã˜ã‚’å‡ºã™ï¼ˆæ‰“æ’ƒæ„Ÿï¼‰
      const noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = 'lowpass';
      noiseFilter.frequency.setValueAtTime(800, t);
      noiseFilter.frequency.linearRampToValueAtTime(0, t + 0.1);

      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.4, t);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(audioCtx.destination);
      noise.start(t);

      // 2. çŸ©å½¢æ³¢ï¼ˆãƒ¬ãƒˆãƒ­ãª8bitæ„Ÿï¼‰
      const osc = audioCtx.createOscillator();
      osc.type = 'square';
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(40, t + 0.1); // ãƒ”ãƒƒãƒãƒ€ã‚¦ãƒ³

      const oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.1, t);
      oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

      osc.connect(oscGain);
      oscGain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + 0.1);
    }

    // ã‚¸ãƒ£ãƒ–æ¤œå‡ºçŠ¶æ…‹
    const jabState = {
      left: { extended: false, lastPunch: 0 },
      right: { extended: false, lastPunch: 0 },
    };

    // MediaPipe ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    const LANDMARKS = {
      LEFT_SHOULDER: 11,
      RIGHT_SHOULDER: 12,
      LEFT_ELBOW: 13,
      RIGHT_ELBOW: 14,
      LEFT_WRIST: 15,
      RIGHT_WRIST: 16,
      LEFT_HIP: 23,
      RIGHT_HIP: 24
    };

    // ãƒœãƒ¼ãƒ³æ¥ç¶šå®šç¾©ï¼ˆã‚¹ã‚±ãƒ«ãƒˆãƒ³æç”»ç”¨ï¼‰
    const POSE_CONNECTIONS = [
      [11, 12], // ä¸¡è‚©
      [11, 13], [13, 15], // å·¦è…•
      [12, 14], [14, 16], // å³è…•
      [11, 23], [12, 24], // èƒ´ä½“
      [23, 24] // è…°
    ];

    // ãƒãƒƒã‚¸æ›´æ–°
    function updateBadge(dot, label, message, state = 'ok') {
      dot.classList.toggle('ok', state === 'ok');
      dot.classList.toggle('warn', state === 'warn');
      label.textContent = message;
    }

    // ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
    function updateCounts() {
      const total = left + right;
      totalEl.textContent = total;
      leftCountEl.textContent = left;
      rightCountEl.textContent = right;
      if (total > best) {
        best = total;
        bestEl.textContent = best;
        log(`ğŸ‰ è¨˜éŒ²æ›´æ–°ï¼ ${best} ã‚¸ãƒ£ãƒ–`);
      }
    }

    // ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºæ›´æ–°
    // ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºæ›´æ–°
    function setTime(ms) {
      const seconds = Math.max(0, ms / 1000);
      timeEl.textContent = `${seconds.toFixed(2)}s`;
      const progress = Math.min(1, (START_DURATION - ms) / START_DURATION);
      barFill.style.width = `${progress * 100}%`;
    }

    // ãƒ­ã‚°è¡¨ç¤º
    function log(message) {
      logEl.textContent = message;
    }

    // ãƒ‘ãƒ«ã‚¹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    function pulse(el) {
      el.classList.remove('pulse');
      void el.offsetWidth;
      el.classList.add('pulse');
    }

    function updateRoundDisplay() {
      const display = document.getElementById('round-display');
      if (display) display.textContent = `${currentRound} / ${maxRounds}`;
    }

    // ã‚²ãƒ¼ãƒ é–‹å§‹
    function startGame() {
      if (running) return;
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      running = true;
      intervalMode = false;
      left = 0;
      right = 0;
      currentRound = 1;
      updateCounts();
      updateRoundDisplay();

      startTime = performance.now();
      setTime(START_DURATION);
      log('ROUND 1 ã‚¹ã‚¿ãƒ¼ãƒˆï¼ãƒœã‚¹ã‚’å€’ã›ï¼');

      boss = new Boss(currentRound);
      shots = [];
      particles = [];

      timerId = requestAnimationFrame(tick);
    }

    // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«é–‹å§‹
    function startInterval() {
      intervalMode = true;
      intervalEndTime = performance.now() + 30000; // 30ç§’
      log(`ROUND ${currentRound} ã‚¯ãƒªã‚¢ï¼ 30ç§’ä¼‘æ†©ã§ã™ã€‚`);
      // æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ç•ªå·ã¸ï¼ˆè¡¨ç¤ºã¯ã¾ã æ›´æ–°ã—ãªã„ã»ã†ãŒã„ã„ã‹ã‚‚ï¼Ÿã„ã‚„ã€ä¼‘æ†©ä¸­ã‚‚ä»Šã®ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¯ãƒªã‚¢æ¸ˆã¿æ„Ÿã‚’å‡ºãã†ï¼‰
    }

    // æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¸
    function nextRound() {
      intervalMode = false;
      currentRound++;
      if (currentRound > maxRounds) {
        endGame(true);
        return;
      }

      updateRoundDisplay();
      startTime = performance.now();
      setTime(START_DURATION);
      log(`ROUND ${currentRound} ã‚¹ã‚¿ãƒ¼ãƒˆï¼`);

      boss = new Boss(currentRound);
      shots = [];
    }

    // ã‚²ãƒ¼ãƒ çµ‚äº†
    function endGame(cleared = false) {
      if (!running) return;
      running = false;
      if (timerId) cancelAnimationFrame(timerId);
      timerId = null;
      setTime(0);
      const total = left + right;
      if (cleared) {
        log(`å…¨ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¯ãƒªã‚¢ï¼ï¼ãŠã‚ã§ã¨ã†ï¼åˆè¨ˆ ${total} ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
      } else {
        log(`ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼... åˆè¨ˆ ${total} ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚`);
      }
      tweetBtn.classList.add('show');
    }

    // ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
    function resetGame() {
      if (timerId) cancelAnimationFrame(timerId);
      running = false;
      intervalMode = false;
      left = 0;
      right = 0;
      startTime = null;
      setTime(START_DURATION);
      updateCounts();
      currentRound = 1;
      updateRoundDisplay();
      log('æº–å‚™å®Œäº†ã€‚STARTãƒœã‚¿ãƒ³ã‹ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§è¨ˆæ¸¬é–‹å§‹ï¼');
      tweetBtn.classList.remove('show');

      boss = null;
      shots = [];
      particles = [];

      // Canvasã‚¯ãƒªã‚¢
      if (overlay.width) {
        ctx.clearRect(0, 0, overlay.width, overlay.height);
      }
    }

    // ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
    function tick(now) {
      if (intervalMode) {
        const remaining = (intervalEndTime - now);
        // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºã¯poseLoopã§è¡Œã†ï¼ˆæç”»ãƒ«ãƒ¼ãƒ—å´ï¼‰
        // ã“ã“ã§ã¯ãƒ­ã‚¸ãƒƒã‚¯ã®ã¿
        if (remaining <= 0) {
          nextRound();
        }
      } else {
        const elapsed = now - startTime;
        const remaining = Math.max(0, START_DURATION - elapsed);
        setTime(remaining);

        if (remaining <= 0) {
          endGame(false);
          return;
        }

        if (boss && boss.isDead) {
          startInterval();
        }
      }
      timerId = requestAnimationFrame(tick);
    }

    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã®ãƒ‘ãƒ³ãƒå‡¦ç†
    function handlePunch(key) {
      if (!running) return;
      const k = key.toLowerCase();
      if (k === 'a' || key === 'ArrowLeft') {
        left += 1;
        updateCounts();
        pulse(leftCard);
      } else if (k === 'l' || key === 'ArrowRight') {
        right += 1;
        updateCounts();
        pulse(rightCard);
      }
      playPunchSound();

      // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã‚‚ã‚·ãƒ§ãƒƒãƒˆãŒå‡ºã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ãƒ»PCç”¨ï¼‰
      if (boss && !boss.isDead) {
        // ç”»é¢ä¸‹ä¸­å¤®ã‹ã‚‰ç™ºå°„
        shots.push(new Shot(0.5, 1.0, boss.x, boss.y));
      }
    }

    // ãƒãƒ¼ã‚ºæç”»
    function drawPose(landmarks) {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      if (!landmarks || landmarks.length === 0) return;

      const w = overlay.width;
      const h = overlay.height;

      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
      POSE_CONNECTIONS.forEach(([a, b]) => {
        const lmA = landmarks[a];
        const lmB = landmarks[b];
        if (lmA && lmB && lmA.visibility > 0.3 && lmB.visibility > 0.3) {
          ctx.beginPath();
          ctx.moveTo((1 - lmA.x) * w, lmA.y * h);
          ctx.lineTo((1 - lmB.x) * w, lmB.y * h);
          ctx.stroke();
        }
      });

      landmarks.forEach((lm, index) => {
        if (lm.visibility < 0.3) return;
        ctx.beginPath();
        ctx.arc((1 - lm.x) * w, lm.y * h, 6, 0, Math.PI * 2);
        ctx.fillStyle = index % 2 === 0 ? '#4ef0c0' : '#ff6b9a';
        ctx.fill();
      });
    }

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    // ---------------------------------------------------------
    // ARãƒãƒˆãƒ«ã‚·ã‚¹ãƒ†ãƒ  (ãƒœã‚¹æˆ¦ä»•æ§˜)
    // ---------------------------------------------------------
    let boss = null;
    let particles = [];
    let shots = [];

    class Boss {
      constructor(round) {
        this.x = 0.5; // ä¸­å¤®
        this.y = 0.4;
        this.radius = 0.15; // ã‚µã‚¤ã‚º

        // ãƒ©ã‚¦ãƒ³ãƒ‰ã”ã¨ã®é›£æ˜“åº¦
        this.maxHp = [15, 30, 50][round - 1] || 50;
        this.hp = this.maxHp;

        this.color = '#ff4757';
        this.shake = 0;
        this.isDead = false;

        this.spawnTime = performance.now();
        this.msg = `ROUND ${round}`;
        this.msgAlpha = 1.0;
      }

      damage(amount = 1) {
        if (this.isDead) return;
        this.hp -= amount;
        this.shake = 10;

        if (this.hp <= 0) {
          this.hp = 0;
          this.isDead = true;
          // æ­»äº¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          spawnExplosion(this.x * overlay.width, this.y * overlay.height, '#ff4757');
          spawnExplosion(this.x * overlay.width, this.y * overlay.height, '#ffa502');
          playPunchSound();
        }
      }

      update() {
        if (this.shake > 0) this.shake *= 0.8;
        if (this.shake < 0.5) this.shake = 0;
        this.msgAlpha *= 0.98;
        this.y = 0.4 + Math.sin((performance.now() - this.spawnTime) / 800) * 0.02;
      }

      draw(ctx, w, h) {
        if (this.isDead) return;

        const cx = this.x * w;
        const cy = this.y * h;
        const offX = (Math.random() - 0.5) * this.shake;
        const offY = (Math.random() - 0.5) * this.shake;

        ctx.save();
        ctx.translate(cx + offX, cy + offY);

        // æœ¬ä½“
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * w, 0, Math.PI * 2);
        ctx.fillStyle = this.color + 'aa';
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#fff';
        ctx.stroke();

        // ç›®
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(-20, -10); ctx.lineTo(-10, 10); ctx.lineTo(-30, 10);
        ctx.moveTo(20, -10); ctx.lineTo(30, 10); ctx.lineTo(10, 10);
        ctx.fill();

        // HPã‚²ãƒ¼ã‚¸
        const hpPct = this.hp / this.maxHp;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * w + 15, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * hpPct));
        ctx.strokeStyle = `hsl(${120 * hpPct}, 80%, 60%)`;
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.stroke();

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        if (this.msgAlpha > 0.01) {
          ctx.fillStyle = `rgba(255, 255, 255, ${this.msgAlpha})`;
          ctx.font = 'bold 40px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(this.msg, 0, -this.radius * w - 30);
        }

        ctx.restore();
      }
    }

    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 5; // ãƒ”ã‚¯ã‚»ãƒ«é€Ÿåº¦
        this.vy = (Math.random() - 0.5) * 5;
        this.life = 1.0;
        this.size = Math.random() * 8 + 4;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
        this.size *= 0.95;
      }

      draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
    }

    class Shot {
      constructor(x, y, targetX, targetY) {
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.life = 1.0;
        this.color = '#4ef0c0';
      }

      update() {
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        this.x += dx * 0.25; // é«˜é€Ÿãƒ›ãƒ¼ãƒŸãƒ³ã‚°
        this.y += dy * 0.25;

        const dist = Math.hypot(dx, dy);
        if (dist < 0.05) {
          this.life = 0;
          return true; // Hit
        }
        return false;
      }

      draw(ctx, w, h) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        // x,yã¯æ­£è¦åŒ–åº§æ¨™
        ctx.arc(this.x * w, this.y * h, 12, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function spawnExplosion(x, y, color) {
      for (let i = 0; i < 20; i++) {
        particles.push(new Particle(x, y, color));
      }
    }

    function spawnParticle(x, y, color) {
      particles.push(new Particle(x, y, color));
    }

    function updateGameObjects() {
      if (!running) return;
      if (boss) boss.update();

      // ã‚·ãƒ§ãƒƒãƒˆæ›´æ–°
      for (let i = shots.length - 1; i >= 0; i--) {
        const s = shots[i];
        if (boss && !boss.isDead) {
          s.targetX = boss.x;
          s.targetY = boss.y;
        }

        const hit = s.update();
        if (hit) {
          if (boss) boss.damage(1);
          shots.splice(i, 1);
        }
      }

      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        if (particles[i].life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function drawGameObjects() {
      if (!overlay.width) return;
      const w = overlay.width;
      const h = overlay.height;
      if (boss) boss.draw(ctx, w, h);
      shots.forEach(s => s.draw(ctx, w, h));
      particles.forEach(p => p.draw(ctx));
    }

    // ã‚¸ãƒ£ãƒ–æ¤œå‡º
    function detectJab(side, landmarks, timestamp) {
      const shoulderIdx = side === 'left' ? LANDMARKS.LEFT_SHOULDER : LANDMARKS.RIGHT_SHOULDER;
      const elbowIdx = side === 'left' ? LANDMARKS.LEFT_ELBOW : LANDMARKS.RIGHT_ELBOW;
      const wristIdx = side === 'left' ? LANDMARKS.LEFT_WRIST : LANDMARKS.RIGHT_WRIST;
      const hipIdx = side === 'left' ? LANDMARKS.LEFT_HIP : LANDMARKS.RIGHT_HIP;

      const shoulder = landmarks[shoulderIdx];
      const elbow = landmarks[elbowIdx];
      const wrist = landmarks[wristIdx];
      const hip = landmarks[hipIdx];

      if (!shoulder || !wrist || !hip || !elbow) return;
      if (shoulder.visibility < 0.3 || wrist.visibility < 0.3) return;

      const wristForward = wrist.z < shoulder.z - 0.15;
      const bodyHeight = Math.abs(shoulder.y - hip.y) || 0.2;
      const armLength = distance(wrist, shoulder);
      const armExtension = armLength / bodyHeight;
      const armExtended = armExtension > 0.65;

      const wristOutward = side === 'left'
        ? wrist.x > shoulder.x + 0.1
        : wrist.x < shoulder.x - 0.1;

      const extended = (wristForward || wristOutward) && armExtended;
      const state = jabState[side];
      const cooldown = 150;

      if (extended && !state.extended && timestamp - state.lastPunch > cooldown) {
        // ã‚·ãƒ§ãƒƒãƒˆç™ºå°„
        let targetX = 0.5;
        let targetY = 0.4;
        if (boss && !boss.isDead) {
          targetX = boss.x;
          targetY = boss.y;
        }
        shots.push(new Shot(wrist.x, wrist.y, targetX, targetY));
        playPunchSound();

        if (side === 'left') {
          left += 1;
          pulse(leftCard);
        } else {
          right += 1;
          pulse(rightCard);
        }
        updateCounts();
        state.lastPunch = timestamp;
      }
      state.extended = extended;
    }

    // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ç®¡ç†
    let intervalMode = false;
    let intervalEndTime = 0;

    async function poseLoop() {
      if (!poseLandmarker || videoEl.readyState < 2) {
        poseLoopId = requestAnimationFrame(poseLoop);
        return;
      }
      try {
        const ts = performance.now();
        const results = poseLandmarker.detectForVideo(videoEl, ts);

        overlay.width = videoEl.videoWidth;
        overlay.height = videoEl.videoHeight;

        // æç”»ã‚¯ãƒªã‚¢
        // drawPoseå†…ã§ã‚¯ãƒªã‚¢ã—ã¦ã„ã‚‹ãŒã€ãƒãƒ¼ã‚ºæœªæ¤œå‡ºæ™‚ã‚‚ã‚¯ãƒªã‚¢å¿…è¦
        // ã“ã“ã§ã¯ã¾ã ã‚¯ãƒªã‚¢ã—ãªã„ï¼ˆdrawPoseã«ä»»ã›ã‚‹ã‹ã€æ˜ç¤ºçš„ã«ã™ã‚‹ã‹ï¼‰
        // ã‚·ãƒ³ãƒ—ãƒ«ã«:
        ctx.clearRect(0, 0, overlay.width, overlay.height);

        if (results.landmarks && results.landmarks.length > 0) {
          const landmarks = results.landmarks[0];
          drawPose(landmarks); // ã“ã“ã§clearRectã—ã¦ãŸãŒã€ä¸Šã§ã‚„ã£ãŸã®ã§å‰Šé™¤ã™ã¹ãã‹ï¼Ÿ
          // drawPoseå†…ã®clearRectã‚’å‰Šé™¤ã™ã¹ãã ãŒã€ã“ã“ã§ã¯ä¸€æ‹¬ç½®æ›ã§ããªã„ã®ã§
          // drawPoseã‚’ã“ã®ç½®æ›ãƒ†ã‚­ã‚¹ãƒˆå†…ã§å†å®šç¾©ã™ã‚‹éš›ã«clearRectã‚’å¤–ã™ã®ãŒãƒ™ã‚¹ãƒˆã€‚
          // -> drawPoseã®å®šç¾©ã‚‚ã“ã“ã§æ›¸ãæ›ãˆã‚‹ã®ã§OKï¼

          updateBadge(poseDot, poseStatus, 'ãƒãƒ¼ã‚ºæ¤œå‡ºä¸­', 'ok');
          lastPoseTs = ts;

          if (running && !intervalMode) {
            detectJab('left', landmarks, ts);
            detectJab('right', landmarks, ts);
          }
        } else if (ts - lastPoseTs > 1500) {
          updateBadge(poseDot, poseStatus, 'ãƒãƒ¼ã‚ºæœªæ¤œå‡º', 'warn');
          // ctx.clearRectã¯ä¸Šã§ã‚„ã£ã¦ã„ã‚‹
        }
      } catch (e) {
        console.error('Pose detection error:', e);
      }

      if (running) {
        updateGameObjects();
        drawGameObjects();

        if (intervalMode) {
          const remaining = Math.max(0, (intervalEndTime - performance.now()) / 1000);
          ctx.save();
          ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
          ctx.fillRect(0, 0, overlay.width, overlay.height);

          ctx.fillStyle = '#fff';
          ctx.font = 'bold 32px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('NICE FIGHT!', overlay.width / 2, overlay.height / 2 - 40);

          ctx.font = 'bold 60px monospace';
          ctx.fillStyle = '#4ef0c0';
          ctx.fillText(`NEXT: ${Math.ceil(remaining)}`, overlay.width / 2, overlay.height / 2 + 30);
          ctx.restore();
        }
      }

      poseLoopId = requestAnimationFrame(poseLoop);
    }

    async function initDetector() {
      if (poseLandmarker) return;
      try {
        updateBadge(modelDot, modelStatus, 'ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...', 'warn');
        log('MediaPipe PoseLandmarkerã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...');
        const vision = await FilesetResolver.forVisionTasks(
          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm'
        );
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
            delegate: 'GPU'
          },
          runningMode: 'VIDEO',
          numPoses: 1
        });
        drawingUtils = new DrawingUtils(ctx);
        updateBadge(modelDot, modelStatus, 'PoseLandmarker æº–å‚™å®Œäº†', 'ok');
        log('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ï¼æº–å‚™ãŒã§ããŸã‚‰STARTï¼');
        poseLoop();
      } catch (e) {
        console.error('Model loading error:', e);
        updateBadge(modelDot, modelStatus, 'ãƒ¢ãƒ‡ãƒ«ã‚¨ãƒ©ãƒ¼', 'warn');
        log('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + e.message);
      }
    }

    async function initCamera() {
      if (cameraReady) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: 640, height: 480 },
          audio: false
        });
        videoEl.srcObject = stream;
        await videoEl.play();
        cameraReady = true;
        updateBadge(camDot, camStatus, 'ã‚«ãƒ¡ãƒ©ç¨¼åƒä¸­', 'ok');
        log('ã‚«ãƒ¡ãƒ©æº–å‚™OKï¼ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...');
        await initDetector();
      } catch (e) {
        console.error('Camera error:', e);
        updateBadge(camDot, camStatus, 'ã‚«ãƒ¡ãƒ©ã‚¨ãƒ©ãƒ¼', 'warn');
        log('ã‚«ãƒ¡ãƒ©ã®è¨±å¯ãŒå¿…è¦ã§ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'Space') {
        e.preventDefault();
        if (!running) startGame();
        return;
      }
      handlePunch(e.key);
    });

    startBtn.addEventListener('click', startGame);
    resetBtn.addEventListener('click', resetGame);
    cameraBtn.addEventListener('click', () => {
      cameraBtn.disabled = true;
      cameraBtn.textContent = 'æº–å‚™ä¸­...';
      initCamera().finally(() => {
        cameraBtn.textContent = cameraReady ? 'ã‚«ãƒ¡ãƒ©ç¨¼åƒä¸­' : 'ã‚«ãƒ¡ãƒ©è¨±å¯';
        cameraBtn.disabled = cameraReady;
      });
    });

    tweetBtn.addEventListener('click', () => {
      const total = left + right;
      const tweetText = `10ç§’ã‚¸ãƒ£ãƒ–é€£æ‰“ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼å…¨3ãƒ©ã‚¦ãƒ³ãƒ‰ã§ ${total} ã‚¸ãƒ£ãƒ–ï¼ã‚ãªãŸã‚‚æŒ‘æˆ¦ã—ã¦ã­ï¼ #${HASHTAG} ${GAME_URL}`;
      const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
      window.open(tweetUrl, '_blank', 'width=550,height=420');
    });

    // åˆæœŸåŒ–å®Ÿè¡Œ
    setTime(START_DURATION);
    updateBadge(camDot, camStatus, 'ã‚«ãƒ¡ãƒ©å¾…æ©Ÿä¸­', 'warn');
    updateBadge(modelDot, modelStatus, 'ãƒ¢ãƒ‡ãƒ«æœªãƒ­ãƒ¼ãƒ‰', 'warn');
    updateBadge(poseDot, poseStatus, 'ãƒãƒ¼ã‚ºæœªæ¤œå‡º', 'warn');
  </script>
</body>

</html>
